/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IActionController {
    adoptDragon(body: DragonAdoptDto): Observable<DragonDto>;
    summonDragon(body: DragonSummonDto): Observable<DragonDto>;
    feedDragon(body: DragonFeedDto): Observable<DragonDto>;
    activateBooster(body: BoosterActivateDto): Observable<void>;
    equipDragon(body: DragonEquipDto): Observable<DragonDto>;
    unequipDragon(body: DragonEquipDto): Observable<DragonDto>;
    renameDragon(body: DragonRenameDto): Observable<DragonDto>;
    resetDragonSkills(id: string): Observable<DragonDto>;
    restoreDragonStamina(id: string): Observable<DragonDto>;
    changeDragonNature(body: DragonChangeNatureDto): Observable<DragonDto>;
    releaseDragon(id: string): Observable<void>;
    startExpedition(body: StartExpeditionDto): Observable<DragonActionDto>;
    checkExpeditions(): Observable<ExpeditionReportDto[]>;
    extendDragonLimit(): Observable<void>;
    buyAuction(id: string): Observable<AuctionBuyResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionController implements IActionController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    adoptDragon(body: DragonAdoptDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/adoptDragon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdoptDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdoptDragon(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processAdoptDragon(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    summonDragon(body: DragonSummonDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/summonDragon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummonDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummonDragon(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processSummonDragon(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    feedDragon(body: DragonFeedDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/feedDragon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedDragon(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processFeedDragon(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    activateBooster(body: BoosterActivateDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/action/activateBooster";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateBooster(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateBooster(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateBooster(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    equipDragon(body: DragonEquipDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/equipDragon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEquipDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEquipDragon(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processEquipDragon(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    unequipDragon(body: DragonEquipDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/unequipDragon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnequipDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnequipDragon(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processUnequipDragon(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    renameDragon(body: DragonRenameDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/renameDragon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenameDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenameDragon(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processRenameDragon(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    resetDragonSkills(id: string): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/resetDragonSkills/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetDragonSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetDragonSkills(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processResetDragonSkills(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    restoreDragonStamina(id: string): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/restoreDragonStamina/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreDragonStamina(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreDragonStamina(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreDragonStamina(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    changeDragonNature(body: DragonChangeNatureDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/action/changeDragonNature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDragonNature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDragonNature(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processChangeDragonNature(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    releaseDragon(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/action/releaseDragon/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseDragon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseDragon(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processReleaseDragon(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    startExpedition(body: StartExpeditionDto): Observable<DragonActionDto> {
        let url_ = this.baseUrl + "/api/v1/action/startExpedition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartExpedition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartExpedition(<any>response_);
                } catch (e) {
                    return <Observable<DragonActionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonActionDto>><any>_observableThrow(response_);
        }));
    }

    protected processStartExpedition(response: HttpResponseBase): Observable<DragonActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonActionDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonActionDto>(<any>null);
    }

    checkExpeditions(): Observable<ExpeditionReportDto[]> {
        let url_ = this.baseUrl + "/api/v1/action/checkExpeditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExpeditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExpeditions(<any>response_);
                } catch (e) {
                    return <Observable<ExpeditionReportDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpeditionReportDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExpeditions(response: HttpResponseBase): Observable<ExpeditionReportDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExpeditionReportDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpeditionReportDto[]>(<any>null);
    }

    extendDragonLimit(): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/action/extendDragonLimit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendDragonLimit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendDragonLimit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendDragonLimit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    buyAuction(id: string): Observable<AuctionBuyResultDto> {
        let url_ = this.baseUrl + "/api/v1/action/buyAuction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyAuction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyAuction(<any>response_);
                } catch (e) {
                    return <Observable<AuctionBuyResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuctionBuyResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processBuyAuction(response: HttpResponseBase): Observable<AuctionBuyResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AuctionBuyResultDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuctionBuyResultDto>(<any>null);
    }
}

export interface IUserController {
    create(body: CreateUserDto): Observable<UserDto>;
    update(id: string, body: UpdateUserDto): Observable<UserDto>;
    getOne(id: string): Observable<UserDto>;
    getAll(body: GetUserDto): Observable<PageUserDto>;
    setAvatar(): Observable<void>;
    getAvatar(): Observable<void>;
    getAvatarPublic(id: string): Observable<void>;
    getPublicData(id: string): Observable<UserPublicDto>;
    requestFriendship(body: FriendshipRequestDto): Observable<void>;
    getPendingFriendshipRequests(): Observable<FriendshipPendingRequestDto[]>;
    respondToFriendshipRequest(body: FriendshipRespondDto): Observable<UserPublicDto>;
    getFriends(): Observable<UserPublicDto[]>;
    getFriendsPublic(id: string): Observable<UserPublicDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class UserController implements IUserController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(body: CreateUserDto): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/v1/user/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    update(id: string, body: UpdateUserDto): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/v1/user/update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    getOne(id: string): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/v1/user/getOne/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    getAll(body: GetUserDto): Observable<PageUserDto> {
        let url_ = this.baseUrl + "/api/v1/user/getAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PageUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PageUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PageUserDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageUserDto>(<any>null);
    }

    setAvatar(): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user/setAvatar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAvatar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAvatar(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAvatar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAvatar(): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user/getAvatar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvatar(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvatar(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvatar(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAvatarPublic(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user/getAvatarPublic/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvatarPublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvatarPublic(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvatarPublic(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getPublicData(id: string): Observable<UserPublicDto> {
        let url_ = this.baseUrl + "/api/v1/user/getPublicData/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicData(<any>response_);
                } catch (e) {
                    return <Observable<UserPublicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPublicDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPublicData(response: HttpResponseBase): Observable<UserPublicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPublicDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPublicDto>(<any>null);
    }

    requestFriendship(body: FriendshipRequestDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user/requestFriendship";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestFriendship(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestFriendship(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRequestFriendship(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getPendingFriendshipRequests(): Observable<FriendshipPendingRequestDto[]> {
        let url_ = this.baseUrl + "/api/v1/user/getPendingFriendshipRequests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingFriendshipRequests(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingFriendshipRequests(<any>response_);
                } catch (e) {
                    return <Observable<FriendshipPendingRequestDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendshipPendingRequestDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingFriendshipRequests(response: HttpResponseBase): Observable<FriendshipPendingRequestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <FriendshipPendingRequestDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendshipPendingRequestDto[]>(<any>null);
    }

    respondToFriendshipRequest(body: FriendshipRespondDto): Observable<UserPublicDto> {
        let url_ = this.baseUrl + "/api/v1/user/respondToFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRespondToFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRespondToFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<UserPublicDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPublicDto>><any>_observableThrow(response_);
        }));
    }

    protected processRespondToFriendshipRequest(response: HttpResponseBase): Observable<UserPublicDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPublicDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPublicDto>(<any>null);
    }

    getFriends(): Observable<UserPublicDto[]> {
        let url_ = this.baseUrl + "/api/v1/user/getFriends";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriends(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriends(<any>response_);
                } catch (e) {
                    return <Observable<UserPublicDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPublicDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriends(response: HttpResponseBase): Observable<UserPublicDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPublicDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPublicDto[]>(<any>null);
    }

    getFriendsPublic(id: string): Observable<UserPublicDto[]> {
        let url_ = this.baseUrl + "/api/v1/user/getFriendsPublic/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendsPublic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendsPublic(<any>response_);
                } catch (e) {
                    return <Observable<UserPublicDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPublicDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendsPublic(response: HttpResponseBase): Observable<UserPublicDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserPublicDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPublicDto[]>(<any>null);
    }
}

export interface IAuthController {
    login(body: UserLoginDto): Observable<UserAuthDto>;
    register(body: UserRegisterDto): Observable<void>;
    confirm(body: UserConfirmDto): Observable<void>;
    refreshToken(body: UserAuthDto): Observable<UserAuthDto>;
    getUserData(): Observable<UserAuthDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthController implements IAuthController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(body: UserLoginDto): Observable<UserAuthDto> {
        let url_ = this.baseUrl + "/api/v1/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<UserAuthDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAuthDto>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<UserAuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserAuthDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAuthDto>(<any>null);
    }

    register(body: UserRegisterDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    confirm(body: UserConfirmDto): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/auth/confirm";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirm(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirm(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    refreshToken(body: UserAuthDto): Observable<UserAuthDto> {
        let url_ = this.baseUrl + "/api/v1/auth/refreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<UserAuthDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAuthDto>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<UserAuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserAuthDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAuthDto>(<any>null);
    }

    getUserData(): Observable<UserAuthDto> {
        let url_ = this.baseUrl + "/api/v1/auth/getUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserData(<any>response_);
                } catch (e) {
                    return <Observable<UserAuthDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAuthDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserData(response: HttpResponseBase): Observable<UserAuthDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserAuthDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAuthDto>(<any>null);
    }
}

export interface IItemController {
    getOwnedItems(): Observable<ItemPageDto>;
    getOwnedFoods(): Observable<ItemPageDto>;
    getRuneBaseRecipes(): Observable<ItemRecipeDto[]>;
    getRuneSpecialRecipes(): Observable<ItemRecipeDto[]>;
    composeRecipe(body: RecipeComposeDto): Observable<ItemDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ItemController implements IItemController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOwnedItems(): Observable<ItemPageDto> {
        let url_ = this.baseUrl + "/api/v1/item/getOwnedItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnedItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnedItems(<any>response_);
                } catch (e) {
                    return <Observable<ItemPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnedItems(response: HttpResponseBase): Observable<ItemPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ItemPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemPageDto>(<any>null);
    }

    getOwnedFoods(): Observable<ItemPageDto> {
        let url_ = this.baseUrl + "/api/v1/item/getOwnedFoods";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwnedFoods(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnedFoods(<any>response_);
                } catch (e) {
                    return <Observable<ItemPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwnedFoods(response: HttpResponseBase): Observable<ItemPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ItemPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemPageDto>(<any>null);
    }

    getRuneBaseRecipes(): Observable<ItemRecipeDto[]> {
        let url_ = this.baseUrl + "/api/v1/item/getRuneBaseRecipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRuneBaseRecipes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRuneBaseRecipes(<any>response_);
                } catch (e) {
                    return <Observable<ItemRecipeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemRecipeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRuneBaseRecipes(response: HttpResponseBase): Observable<ItemRecipeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ItemRecipeDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemRecipeDto[]>(<any>null);
    }

    getRuneSpecialRecipes(): Observable<ItemRecipeDto[]> {
        let url_ = this.baseUrl + "/api/v1/item/getRuneSpecialRecipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRuneSpecialRecipes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRuneSpecialRecipes(<any>response_);
                } catch (e) {
                    return <Observable<ItemRecipeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemRecipeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRuneSpecialRecipes(response: HttpResponseBase): Observable<ItemRecipeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ItemRecipeDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemRecipeDto[]>(<any>null);
    }

    composeRecipe(body: RecipeComposeDto): Observable<ItemDto> {
        let url_ = this.baseUrl + "/api/v1/item/composeRecipe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComposeRecipe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComposeRecipe(<any>response_);
                } catch (e) {
                    return <Observable<ItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processComposeRecipe(response: HttpResponseBase): Observable<ItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ItemDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemDto>(<any>null);
    }
}

export interface IAchievementsController {
    getUserAchievements(): Observable<AchievementsDto>;
    getUserPublicAchievements(id: string): Observable<AchievementsDto>;
    getAllAchievements(): Observable<AchievementDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class AchievementsController implements IAchievementsController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserAchievements(): Observable<AchievementsDto> {
        let url_ = this.baseUrl + "/api/v1/achievements/getUserAchievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserAchievements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserAchievements(<any>response_);
                } catch (e) {
                    return <Observable<AchievementsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AchievementsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserAchievements(response: HttpResponseBase): Observable<AchievementsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AchievementsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AchievementsDto>(<any>null);
    }

    getUserPublicAchievements(id: string): Observable<AchievementsDto> {
        let url_ = this.baseUrl + "/api/v1/achievements/getUserPublicAchievements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPublicAchievements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPublicAchievements(<any>response_);
                } catch (e) {
                    return <Observable<AchievementsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AchievementsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPublicAchievements(response: HttpResponseBase): Observable<AchievementsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AchievementsDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AchievementsDto>(<any>null);
    }

    getAllAchievements(): Observable<AchievementDto[]> {
        let url_ = this.baseUrl + "/api/v1/achievements/getAllAchievements";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAchievements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAchievements(<any>response_);
                } catch (e) {
                    return <Observable<AchievementDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AchievementDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAchievements(response: HttpResponseBase): Observable<AchievementDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AchievementDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AchievementDto[]>(<any>null);
    }
}

export interface IMailController {
    send(body: MailSendDto): Observable<MailDto>;
    read(id: string): Observable<MailDto>;
    checkUnread(): Observable<MailPageDto>;
    getAll(body: MailGetDto): Observable<MailPageDto>;
}

@Injectable({
    providedIn: 'root'
})
export class MailController implements IMailController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    send(body: MailSendDto): Observable<MailDto> {
        let url_ = this.baseUrl + "/api/v1/mail/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(<any>response_);
                } catch (e) {
                    return <Observable<MailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailDto>><any>_observableThrow(response_);
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<MailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MailDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailDto>(<any>null);
    }

    read(id: string): Observable<MailDto> {
        let url_ = this.baseUrl + "/api/v1/mail/read/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRead(<any>response_);
                } catch (e) {
                    return <Observable<MailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailDto>><any>_observableThrow(response_);
        }));
    }

    protected processRead(response: HttpResponseBase): Observable<MailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MailDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailDto>(<any>null);
    }

    checkUnread(): Observable<MailPageDto> {
        let url_ = this.baseUrl + "/api/v1/mail/checkUnread";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUnread(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUnread(<any>response_);
                } catch (e) {
                    return <Observable<MailPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processCheckUnread(response: HttpResponseBase): Observable<MailPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MailPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailPageDto>(<any>null);
    }

    getAll(body: MailGetDto): Observable<MailPageDto> {
        let url_ = this.baseUrl + "/api/v1/mail/getAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MailPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MailPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<MailPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MailPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MailPageDto>(<any>null);
    }
}

export interface IDragonController {
    create(body: DragonCreateDto): Observable<DragonDto>;
    getOne(id: string): Observable<DragonDto>;
    getAll(body: DragonGetDto): Observable<DragonPageDto>;
    getBest(): Observable<DragonBestDto[]>;
    getOwned(): Observable<DragonDto[]>;
    getPublicPlayerDragons(id: string): Observable<DragonPublicDto[]>;
    calculateStatistics(id: string): Observable<BattleDragonDto>;
    startBattle(body: BattleStartDto): Observable<BattleResultDto>;
    startGuardianBattle(body: BattleGuardianStartDto): Observable<BattleResultDto>;
    learnSkill(body: SkillLearnDto): Observable<DragonDto>;
    getTamerActions(): Observable<DragonTamerActionDto[]>;
    getSummonActions(): Observable<DragonSummonActionDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class DragonController implements IDragonController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(body: DragonCreateDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    getOne(id: string): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/getOne/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    getAll(body: DragonGetDto): Observable<DragonPageDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/getAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DragonPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DragonPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonPageDto>(<any>null);
    }

    getBest(): Observable<DragonBestDto[]> {
        let url_ = this.baseUrl + "/api/v1/dragon/getBest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBest(<any>response_);
                } catch (e) {
                    return <Observable<DragonBestDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonBestDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBest(response: HttpResponseBase): Observable<DragonBestDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonBestDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonBestDto[]>(<any>null);
    }

    getOwned(): Observable<DragonDto[]> {
        let url_ = this.baseUrl + "/api/v1/dragon/getOwned";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOwned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwned(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOwned(response: HttpResponseBase): Observable<DragonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto[]>(<any>null);
    }

    getPublicPlayerDragons(id: string): Observable<DragonPublicDto[]> {
        let url_ = this.baseUrl + "/api/v1/dragon/getPublicPlayerDragons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicPlayerDragons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicPlayerDragons(<any>response_);
                } catch (e) {
                    return <Observable<DragonPublicDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonPublicDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPublicPlayerDragons(response: HttpResponseBase): Observable<DragonPublicDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonPublicDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonPublicDto[]>(<any>null);
    }

    calculateStatistics(id: string): Observable<BattleDragonDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/calculateStatistics/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalculateStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalculateStatistics(<any>response_);
                } catch (e) {
                    return <Observable<BattleDragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BattleDragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processCalculateStatistics(response: HttpResponseBase): Observable<BattleDragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BattleDragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BattleDragonDto>(<any>null);
    }

    startBattle(body: BattleStartDto): Observable<BattleResultDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/startBattle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartBattle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartBattle(<any>response_);
                } catch (e) {
                    return <Observable<BattleResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BattleResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processStartBattle(response: HttpResponseBase): Observable<BattleResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BattleResultDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BattleResultDto>(<any>null);
    }

    startGuardianBattle(body: BattleGuardianStartDto): Observable<BattleResultDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/startGurdianBattle";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartGuardianBattle(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartGuardianBattle(<any>response_);
                } catch (e) {
                    return <Observable<BattleResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BattleResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processStartGuardianBattle(response: HttpResponseBase): Observable<BattleResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BattleResultDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BattleResultDto>(<any>null);
    }

    learnSkill(body: SkillLearnDto): Observable<DragonDto> {
        let url_ = this.baseUrl + "/api/v1/dragon/learnSkill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLearnSkill(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLearnSkill(<any>response_);
                } catch (e) {
                    return <Observable<DragonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonDto>><any>_observableThrow(response_);
        }));
    }

    protected processLearnSkill(response: HttpResponseBase): Observable<DragonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonDto>(<any>null);
    }

    getTamerActions(): Observable<DragonTamerActionDto[]> {
        let url_ = this.baseUrl + "/api/v1/dragon/getTamerActions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTamerActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTamerActions(<any>response_);
                } catch (e) {
                    return <Observable<DragonTamerActionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonTamerActionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTamerActions(response: HttpResponseBase): Observable<DragonTamerActionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonTamerActionDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonTamerActionDto[]>(<any>null);
    }

    getSummonActions(): Observable<DragonSummonActionDto[]> {
        let url_ = this.baseUrl + "/api/v1/dragon/getSummonActions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSummonActions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSummonActions(<any>response_);
                } catch (e) {
                    return <Observable<DragonSummonActionDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DragonSummonActionDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSummonActions(response: HttpResponseBase): Observable<DragonSummonActionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DragonSummonActionDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DragonSummonActionDto[]>(<any>null);
    }
}

export interface IDragonActionController {
    getExpeditions(): Observable<ExpeditionPageDto>;
}

@Injectable({
    providedIn: 'root'
})
export class DragonActionController implements IDragonActionController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getExpeditions(): Observable<ExpeditionPageDto> {
        let url_ = this.baseUrl + "/api/v1/action/getExpeditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExpeditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExpeditions(<any>response_);
                } catch (e) {
                    return <Observable<ExpeditionPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpeditionPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetExpeditions(response: HttpResponseBase): Observable<ExpeditionPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExpeditionPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpeditionPageDto>(<any>null);
    }
}

export interface IDragonSkillsController {
    getSkills(body: SkillGetDto): Observable<SkillDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class DragonSkillsController implements IDragonSkillsController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSkills(body: SkillGetDto): Observable<SkillDto[]> {
        let url_ = this.baseUrl + "/api/v1/dragonSkills/getSkills";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSkills(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSkills(<any>response_);
                } catch (e) {
                    return <Observable<SkillDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SkillDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSkills(response: HttpResponseBase): Observable<SkillDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SkillDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SkillDto[]>(<any>null);
    }
}

export interface IAlchemyController {
    getMixtureRecipes(): Observable<MixtureRecipeDto[]>;
    composeMixture(body: MixtureComposeDto): Observable<MixtureDto>;
    getOnGoingMixtures(body: MixtureGetDto): Observable<MixturePageDto>;
    collectMixture(id: string): Observable<ItemDto>;
    getBoosterRecipes(): Observable<BoosterRecipeDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class AlchemyController implements IAlchemyController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getMixtureRecipes(): Observable<MixtureRecipeDto[]> {
        let url_ = this.baseUrl + "/api/v1/alchemy/getMixtureRecipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMixtureRecipes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMixtureRecipes(<any>response_);
                } catch (e) {
                    return <Observable<MixtureRecipeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MixtureRecipeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMixtureRecipes(response: HttpResponseBase): Observable<MixtureRecipeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MixtureRecipeDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MixtureRecipeDto[]>(<any>null);
    }

    composeMixture(body: MixtureComposeDto): Observable<MixtureDto> {
        let url_ = this.baseUrl + "/api/v1/alchemy/prepareMixture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComposeMixture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComposeMixture(<any>response_);
                } catch (e) {
                    return <Observable<MixtureDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MixtureDto>><any>_observableThrow(response_);
        }));
    }

    protected processComposeMixture(response: HttpResponseBase): Observable<MixtureDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MixtureDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MixtureDto>(<any>null);
    }

    getOnGoingMixtures(body: MixtureGetDto): Observable<MixturePageDto> {
        let url_ = this.baseUrl + "/api/v1/alchemy/getOngoingMixtures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOnGoingMixtures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOnGoingMixtures(<any>response_);
                } catch (e) {
                    return <Observable<MixturePageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MixturePageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOnGoingMixtures(response: HttpResponseBase): Observable<MixturePageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MixturePageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MixturePageDto>(<any>null);
    }

    collectMixture(id: string): Observable<ItemDto> {
        let url_ = this.baseUrl + "/api/v1/alchemy/collectMixture/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectMixture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectMixture(<any>response_);
                } catch (e) {
                    return <Observable<ItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processCollectMixture(response: HttpResponseBase): Observable<ItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ItemDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ItemDto>(<any>null);
    }

    getBoosterRecipes(): Observable<BoosterRecipeDto[]> {
        let url_ = this.baseUrl + "/api/v1/alchemy/getBoosterRecipes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBoosterRecipes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBoosterRecipes(<any>response_);
                } catch (e) {
                    return <Observable<BoosterRecipeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BoosterRecipeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBoosterRecipes(response: HttpResponseBase): Observable<BoosterRecipeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BoosterRecipeDto[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BoosterRecipeDto[]>(<any>null);
    }
}

export interface IAuctionController {
    create(body: AuctionCreateDto): Observable<AuctionDto>;
    getAll(body: AuctionGetDto): Observable<AuctionPageDto>;
    cancel(id: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AuctionController implements IAuctionController {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(body: AuctionCreateDto): Observable<AuctionDto> {
        let url_ = this.baseUrl + "/api/v1/auction/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<AuctionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuctionDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<AuctionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AuctionDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuctionDto>(<any>null);
    }

    getAll(body: AuctionGetDto): Observable<AuctionPageDto> {
        let url_ = this.baseUrl + "/api/v1/auction/getAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AuctionPageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuctionPageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AuctionPageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AuctionPageDto>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuctionPageDto>(<any>null);
    }

    cancel(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/auction/cancel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export enum DragonNature {
    Fire = "Fire",
    Water = "Water",
    Wind = "Wind",
    Earth = "Earth",
    Electric = "Electric",
    Nature = "Nature",
    Dark = "Dark",
}

export interface DragonAdoptDto {
    name: string;
    nature: DragonNature;
}

export enum DragonActionType {
    None = "None",
    Expedition = "Expedition",
    Training = "Training",
}

export interface DragonActionDto {
    id?: number;
    type: DragonActionType;
    expeditionId?: string;
    awardCollected: boolean;
    nextAction: number;
}

export interface DragonSkillsDto {
    id: number;
    innateSpeed: number;
    innerFlow: number;
    luckyStrike: number;
    greatVigor: number;
    thoughtfulStrike: number;
    beginnersLuck: number;
    fireBreath: number;
    soundBody: number;
    pugnaciousStrike: number;
    roughSkin: number;
    magicArrow: number;
    block: number;
    armorPenetration: number;
    rage: number;
    fireBolt: number;
    iceBolt: number;
    airVector: number;
    rockBlast: number;
    staticStrike: number;
    thunderbolt: number;
    leafCut: number;
    criticalDrain: number;
    poison: number;
    lifeLink: number;
    dodge: number;
    treasureHunter: number;
    lethalBlow: number;
    inferialBlessing: number;
    freeze: number;
    zeal: number;
    deepWounds: number;
    superCharge: number;
    enchantedBarrier: number;
    terribleOmen: number;
}

export enum ItemRarity {
    Common = "Common",
    Scarce = "Scarce",
    Rare = "Rare",
    Mythical = "Mythical",
}

export enum ItemType {
    Food = "Food",
    Ingredient = "Ingredient",
    Equipment = "Equipment",
    Booster = "Booster",
}

export enum FoodType {
    Strength = "Strength",
    StrengthPotion = "StrengthPotion",
    Dexterity = "Dexterity",
    DexterityPotion = "DexterityPotion",
    Endurance = "Endurance",
    EndurancePotion = "EndurancePotion",
    Will = "Will",
    WillPotion = "WillPotion",
    Luck = "Luck",
    LuckPotion = "LuckPotion",
    Complete = "Complete",
    CompletePotion = "CompletePotion",
}

export enum EquipmentType {
    Armor = "Armor",
    Charm = "Charm",
    Rune = "Rune",
}

export interface EquipmentStatisticsDto {
    strength: number;
    dexterity: number;
    endurance: number;
    will: number;
    luck: number;
    allAttributes: number;
    criticalChance: number;
    criticalPower: number;
    health: number;
    armor: number;
    resistance: number;
    speed: number;
    initiative: number;
    mana: number;
    manaRegeneration: number;
    healthRegeneration: number;
    physicalAttack: number;
    magicalAttack: number;
    dodge: number;
    healthBoost: number;
    armorBoost: number;
    physicalAttackBoost: number;
    criticalChanceBoost: number;
    magicalAttackBoost: number;
    manaBoost: number;
    speedBoost: number;
    dodgeBoost: number;
}

export interface ItemDto {
    id?: number;
    userId?: number;
    dragonId?: number;
    uid: string;
    name: string;
    level: number;
    rarity: ItemRarity;
    quantity?: number;
    position?: number;
    type: ItemType;
    foodType?: FoodType;
    equipmentType?: EquipmentType;
    statistics: EquipmentStatisticsDto;
}

export interface DragonDto {
    id: number;
    userId?: number;
    user?: any;
    action: DragonActionDto;
    skills: DragonSkillsDto;
    runes: ItemDto[];
    boosterUid: string;
    booster: ItemDto;
    battledWith: number[];
    unlockedExpeditions: string[];
    name: string;
    skillPoints: number;
    nextFeed: number;
    nature: DragonNature;
    level: number;
    stamina: number;
    experience: number;
    strength: number;
    dexterity: number;
    endurance: number;
    will: number;
    luck: number;
}

export interface DragonSummonDto {
    actionUid: string;
    name: string;
    nature: DragonNature;
}

export interface DragonFeedDto {
    dragonId: number;
    itemId: number;
}

export interface BoosterActivateDto {
    dragonId: number;
    boosterRecipeUid: string;
}

export interface DragonEquipDto {
    dragonId: number;
    itemId: number;
}

export interface DragonRenameDto {
    dragonId: number;
    newName: string;
}

export interface DragonChangeNatureDto {
    dragonId: number;
    newNature: DragonNature;
}

export interface StartExpeditionDto {
    dragonId: number;
    expeditionUid: string;
}

export interface ExpeditionReportDto {
    dragonName: string;
    expeditionName: string;
    gainedGold: number;
    loots: ItemDto[];
}

export interface AuctionBuyResultDto {
    consumedGold: number;
}

export interface CreateUserDto {
    email: string;
    password: string;
    nickname: string;
}

export interface AchievementsDto {
    id: number;
    expeditionTime: number;
    dragonOwnerI: boolean;
    dragonOwnerII: boolean;
    dragonOwnerIII: boolean;
    persistentBreederI: boolean;
    persistentBreederII: boolean;
    persistentBreederIII: boolean;
    curiousExplorerI: boolean;
    curiousExplorerII: boolean;
    curiousExplorerIII: boolean;
    dragonTrainerI: boolean;
    dragonTrainerII: boolean;
    dragonTrainerIII: boolean;
    croesusI: boolean;
    croesusII: boolean;
    croesusIII: boolean;
}

export interface UserDto {
    id?: number;
    email: string;
    password?: string;
    nickname: string;
    achievements?: AchievementsDto;
    gold: number;
    ownedDragons: number;
    maxOwnedDragons: number;
    isConfirmed: boolean;
    actionToken?: string;
    actionTokenValidity?: number;
}

export interface UpdateUserDto {
    email?: string;
    password?: string;
    nickname?: string;
    ownedDragons?: number;
    maxOwnedDragons?: number;
}

export interface GetUserDto {
    email?: string;
    nickname?: string;
    page?: number;
    limit?: number;
}

export interface PageMetaDto {
    totalItems?: number;
    itemCount?: number;
    itemsPerPage?: number;
    totalPages?: number;
    currentPage?: number;
}

export interface PageUserDto {
    meta: PageMetaDto;
    data: UserDto[];
}

export interface UserPublicDto {
    id?: number;
    nickname: string;
    achievements?: AchievementsDto;
    gold: number;
}

export interface FriendshipRequestDto {
    targetUserId: number;
}

export interface FriendshipPendingRequestDto {
    requesterId: number;
    requesterNick: string;
}

export interface FriendshipRespondDto {
    requesterId: number;
    accept: boolean;
}

export interface UserLoginDto {
    nickname: string;
    password: string;
}

export interface UserAuthDto {
    id: number;
    email: string;
    nickname: string;
    accessToken: string;
    expires?: string;
    gold: number;
    ownedDragons: number;
    maxOwnedDragons: number;
}

export interface UserRegisterDto {
    email: string;
    password: string;
    nickname: string;
}

export interface UserConfirmDto {
    activationCode: string;
}

export interface ItemPageDto {
    meta: PageMetaDto;
    data: ItemDto[];
}

export interface ItemRecipeDto {
    uid: string;
    product: ItemDto;
    ingredients: ItemDto[];
}

export interface RecipeComposeDto {
    recipeUid: string;
}

export interface AchievementDto {
    uid: string;
    name: string;
    hint: string;
}

export interface MailSendDto {
    senderId: number;
    receiverName: string;
    topic: string;
    message: string;
}

export interface MailDto {
    id: number;
    sentDate: number;
    senderId: number;
    senderName: string;
    receiverId: number;
    topic: string;
    message: string;
    isRead: boolean;
}

export interface MailPageDto {
    meta: PageMetaDto;
    data: MailDto[];
}

export interface MailGetDto {
    page?: number;
    limit?: number;
}

export interface DragonCreateDto {
    name: string;
    nature: DragonNature;
    level?: number;
    strength?: number;
    dexterity?: number;
    endurance?: number;
    will?: number;
    luck?: number;
    skills?: DragonSkillsDto;
}

export interface DragonGetDto {
    minLevel?: number;
    maxLevel?: number;
    page?: number;
    limit?: number;
}

export interface DragonPageDto {
    meta: PageMetaDto;
    data: DragonDto[];
}

export interface DragonBestDto {
    id: number;
    name: string;
    level: number;
    experience: number;
    userId: number;
    userNickname: string;
}

export interface DragonPublicDto {
    id: number;
    userId?: number;
    name: string;
    nature: DragonNature;
    level: number;
    experience: number;
}

export interface BattleDragonDto {
    id?: number;
    userId?: number;
    user?: any;
    action?: DragonActionDto;
    skills?: DragonSkillsDto;
    runes?: ItemDto[];
    boosterUid?: string;
    booster?: ItemDto;
    battledWith?: number[];
    unlockedExpeditions?: string[];
    name?: string;
    skillPoints?: number;
    nextFeed?: number;
    nature?: DragonNature;
    level?: number;
    stamina?: number;
    experience?: number;
    strength?: number;
    dexterity?: number;
    endurance?: number;
    will?: number;
    luck?: number;
    maxHealth: number;
    health: number;
    maxMana: number;
    mana: number;
    manaRegen: number;
    physicalAttack: number;
    magicalAttack: number;
    armor: number;
    resistance: number;
    speed: number;
    initiative: number;
    critChance: number;
    critPower: number;
    dodgeChance: number;
    healthRegen: number;
    deepWounds?: number;
}

export interface BattleStartDto {
    ownedDragonId: number;
    enemyDragonId: number;
}

export interface BattleResultDto {
    ownedDragon: any;
    enemyDragon: any;
    logs: string[];
    result: string;
}

export interface BattleGuardianStartDto {
    ownedDragonId: number;
    expeditionUid: string;
}

export interface SkillLearnDto {
    dragonId: number;
    skillUid: string;
}

export interface DragonTamerActionDto {
    uid: string;
    hint: string;
    costFactor: number;
    baseCost: number;
    requiredLevel: number;
    withoutDragon: boolean;
    requiredItems: ItemDto[];
}

export interface DragonSummonActionDto {
    uid: string;
    hint: string;
    nature: DragonNature;
    cost: number;
    requiredItems: ItemDto[];
}

export interface ExpeditionGuardianDto {
    uid: string;
    name: string;
    level: number;
    strength: number;
    dexterity: number;
    endurance: number;
    will: number;
    luck: number;
    skills: DragonSkillsDto;
    runes: string[];
    boosterUid: string;
}

export interface ExpeditionDto {
    uid: string;
    name: string;
    hint: string;
    level: number;
    gold: number;
    extraGold: number;
    loots: ItemDto[];
    extraLoots: ItemDto[];
    minimumActionTime: number;
    guardian: ExpeditionGuardianDto;
}

export interface ExpeditionPageDto {
    meta: PageMetaDto;
    data: ExpeditionDto[];
}

export interface SkillGetDto {
    minLevel?: number;
    maxLevel?: number;
    requiredNature?: string;
}

export interface SkillDto {
    uid: string;
    name: string;
    hint: string;
    level: number;
    requiredNature: DragonNature[];
}

export interface MixtureRecipeDto {
    uid: string;
    product: ItemDto;
    ingredients: ItemDto[];
    prepareTime: number;
}

export interface MixtureComposeDto {
    recipeUid: string;
}

export interface MixtureDto {
    id?: number;
    userId?: number;
    uid: string;
    startedOn: number;
    readyOn: number;
    collected: boolean;
    productName: string;
}

export interface MixtureGetDto {
    page?: number;
    limit?: number;
}

export interface MixturePageDto {
    meta: PageMetaDto;
    data: MixtureDto[];
}

export interface BoosterRecipeDto {
    uid: string;
    product: ItemDto;
    ingredients: ItemDto[];
}

export interface AuctionCreateDto {
    itemId: number;
    duration: number;
    unitGoldPrice: number;
    quantity: number;
}

export interface AuctionDto {
    id: number;
    sellerId: number;
    endTime: number;
    totalGoldPrice: number;
    item: any;
    quantity: number;
    active: boolean;
    finalized: boolean;
}

export interface AuctionGetDto {
    ownedByUser?: boolean;
    name?: string;
    type?: string;
    requiredRarity?: string;
    minLevel?: number;
    maxLevel?: number;
    page?: number;
    limit?: number;
}

export interface AuctionPageDto {
    meta: PageMetaDto;
    data: AuctionDto[];
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}